* Protocol
** Block format
*** Challenge block
| Size | Data                      |
|------+---------------------------|
|    8 | version                   |
|    8 | network ID                |
|   32 | ID                        |
|  256 | white player's pubic key  |
|  256 | black player's public key |
|   32 | paired game ID            |
|   64 | timestamp                 |
*** Accept block
| Size | Data      |
|------+-----------|
|   64 | signature |
*** Move block
| Size | Data         |
|------+--------------|
|    8 | start square |
|    8 | end square   |
|   64 | signature    |
**** Square notes
***** In normal usage, refers to square on board (a1 being 0, h1 being 7, h8 being 63)
***** Special codes can be used to signal things like castling, resigning, etc.
**** Signature notes
***** If follows move block, contains bits 13-76 of previous block and squares of this move block 
***** If follows game block TODO
** Single-game sequence
1) Alice creates a challenge block with her and Bob's key
2) Alice signs the challenge block with an accept block
3) Alice broadcasts the challenge block + accept block to the network
4) The network verifies the timestamp and signed block
   - If the timestamp is too old (a week?), reject it (or forget about it)
   - If the timestamp is in the future, reject it (maybe with some grace)
5) Bob receives the blockchain containing his public key
6) Bob verifies Alice's signature
7) If Bob agrees to the challenge, he adds broadcasts his signed accept block as well
   - If he doesn't, he just ignores it
8) Once whoever's white has both accept blocks, they create their first move, and the game progresses
   - Nodes should not accept moves if a challenge doesn't have both signatues
** Paired game sequence
- Same as single-game sequence, except nodes don't accept any moves until paired game is accepted too
- Paired games will expire if time hits and all accept blocks aren't registered
* Program flow
** Startup
** Load key
*** Not necessary if it's a non-player node
** Look for peers
*** Query hardcoded/arg points
** Update database
** Listen for connections and transmit moves
*** Incoming moves
*** Requests for data
*** Notify peers
** Events
*** Incoming network message
**** Receive block
* Design goals
** Allow an authoritative record of chess games to be stores in a distributed ledger.
** Do not tax user machines (preferably no proof-of-work)
** Support challenge pairs
* Design wishes
** Timestamps
* Design questions
** How do different versions work?
** Add an expiration timestamp on challenges?
*** To avoid having to keep unaccepted challenges in the network
*** Network could refuse timestamps too much in the future (and past timestamps are dropped)
** How does the program receive moves from the user?
* Differences from bitcoin domain
** No double-spend problem (if multiple moves are given, opponent chooses one)
** Transactions are always limited to two parties
